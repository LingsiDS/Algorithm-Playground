//首先注意到，一段绳子拆分成若干段，若干段之积最大只和每段的长度有关，比如某个答案中绳子开头一段被拆分为长度为len的一段
//中间某段也被拆分为长度为len的某段，这两段绳子的最大子段之积相等，所以我们可以得出，【状态只与绳子的长度有关，而与绳子的位置无关】

//所以我们定义状态f[n]表示：长度为n的绳子，至少拆分为2段，且各段之和为n，各段之积的最大值为f[n]

//转移方程：当求长度为n的绳子的划分方案时，可以考虑将长度为n的绳子划分为两段，第一段的长度为l, 第二段的长度为n-l，并且1 <= l < n
//要使得f[n]最大，那么两段之间的划分也应该最大，这样两段的积才能更大，所以转移方程为f[n] = f[l] * f[n - l]

//我们利用递归的方法计算转移方程，其中对于某些长度的划分，会计算多次，为了避免重复计算，开辟一个数组记录每次计算的结果，如果该状态被计算过
//则直接返回，否则计算该状态

//时间复杂度：每个状态被计算一次，最多计算n次，每个状态转移需要O(n)，一共n个状态所以总的时间复杂度为O(n^2)，空间复杂度O(n)
class Solution {
public:
    int cuttingRope(int n) {
        //因为至少要拆分为2个段之和
        if (n == 2) return 1; //但是2不拆分比拆分更大，特殊处理一下
        if (n == 3) return 2;//3不拆分比拆分更大，特殊处理一下

        vector<int> f(n + 1, -1);//绳子长为n，拆分成至少两段，结果为最大的积
        f[0] = 1;
        f[1] = 1;//长度为1
        dfs(n, f);
        return f[n];
    }

    int dfs(int n, vector<int> &f) {
        if (f[n] != -1) return f[n]; //记忆化递归
        int res = n;//需要考虑不拆分的情况，比如n = 2, 3，不拆分分别为2，3，f[5] = f[2] * f[3]
        for (int l = 1; l < n; l++) {//将长度拆分为l, n - l 两段，1 <= l < n，注意l不能等于n，否则无限递归
            res = max(res, dfs(l, f) * dfs(n - l, f));//取最大的拆分方案
        }
        return f[n] = res;
    }
};


//数学，证明见https://www.acwing.com/solution/content/368/
class Solution {
public:
    int cuttingRope(int n) {
        if (n == 2) return 1;
        if (n == 3) return 2;

        int res = 1;
        while (n >= 5) n -= 3, res *= 3;
        //此时n只可能为2，3，4
        return res * n;
    }
};
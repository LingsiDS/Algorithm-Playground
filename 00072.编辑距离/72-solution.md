动态规划经典例题，先假设字符串`a`，`b`下标从1开始，状态定义`dp[i][j]`：表示将`a[1~i]`变成`b[1~j]`的所有方式的集合，属性：最小操作次数

a变成b有3种方式

- 第一种方式：**增加**，要使得增加后`a[1~i]`等于`b[1~j]`，可以在`a[1~i]`等于`b[1~j-1]`匹配的情况下，在`a`最后增加`b[j]`即可，所以这一步的转移为：`dp[i][j] = dp[i][j-1] + 1`; 
- 第二种方式：**删除**，要使得删除后`a[1~i-1]`与`b[1~j]`匹配，删除`a[i]`即可，这一步的转移为：`dp[i][j] = dp[i-1][j] + 1`; 
- 第三种方式：**修改**，如果`a[1~i-1]`已经和`b[1~j-1]`匹配，则只需要将`a[i]`修改为`b[j]`即可，但是
  要注意`a[i]`可能等于`b[j]`，这样就不需要修改了，这一步的转移为:`dp[i][j] = dp[i-1][j-1] + a[i] == b[j]`;

确定完转移方程，考虑边界情况，为了方便`dp`的下标从1开始，`dp`下标为1对应字符串下标为0，这样的话`dp[0][i]`表示`a`为**空串**要变成`b[1~i]`所需要的最小操作次数，最小操作次数就是增加`i`个字符，所以`dp[0][i] = i`; 同样`dp[i][0]`表示`a[1~i]`变成**空串**最少需要的操作次数，显然最少需要的操作次数就是删除`a`中`i`个字符`dp[i][0] = i`;



时间复杂度$O(n*m)$，空间复杂度$O(n*m)$